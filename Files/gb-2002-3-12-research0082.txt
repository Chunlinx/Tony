                    Rationale        Unadorned genomic sequence data is simply a string of        As Ts Gs and Cs with perhaps an associated confidence        value for each base In this raw state sequence data        provides very little biological insight To utilize any        sequence it must be interpreted in the context of other        biological knowledge This is the process of annotation        the task of adding explanatory notations to the sequence        text We define an annotation as the biological evaluation        and explanation of a specific region on a nucleic acid        sequence that includes but is not limited to gene        transcripts Any feature that can be anchored to the        sequence  for example an exon a promoter a transposable        element a regulatory region or a CpG island  is an        annotation The genomic sequence will stabilize and reach a        finite endpoint but the annotations will continue to        evolve indefinitely as biological knowledge increases To        understand the genetic legacy of an organism we must        interpret its genomic sequence translating the information        it contains in molecular form into humanreadable        annotations        Part of this process is purely computational and in its        simplest terms can be described as a process of        recognition can anything be located that is somehow        already familiar The first obvious tactic is to collect        sequences that may represent interesting biological        features and to search the genomic sequence in order to        discover the presence or absence of similar sequences The        principle is the same whether the sequences used in this        comparison are expressed sequence tags ESTs fulllength        cDNAs repeated elements or highly conserved sequences and        whether the sequences come from the same species a closely        related species or a distantly related species it is only        the alignment algorithm that will vary appropriately for        example BLAST   Sim   or BLAT   The second        general tactic is to utilize what is already known about        specific classes of sequence features to construct an        abstract model representing this combined knowledge and to        search the genomic sequence to identify locations that        match this model for example hidden Markov models HMM            and stochastic contextfree grammars SCFG                  While these computational examinations reveal the        general character of the primary sequence the results are        still of limited use for further functional biological        research      For example BLAST provides        alignment results composed of highscoring pairs HSPs        indicating local regions of similarity but in total these        typically do not provide the best global alignment over the        entire length of the peptide to the genomic sequence        Similarly geneprediction programs can generate quite        different results depending on the length of the genomic        sequence analyzed and the gene density of the surrounding        sequence Even systems that strive to make adjustments and        collate the results of all the analyses are unable to        consistently provide accurate biological models see          for a more detailed discussion Our current computational        analysis capabilities are useful for primary annotation        but the biological imprecision of the results especially        within eukaryote genomes makes expert evaluation        absolutely essential to ensure the correctness of the        annotations In addition this step is required to deepen        our understanding by connecting these annotations to all        the experimentally known biology of the organism        Software developers are familiar with debugging tools        and techniques Apollo is an analogous tool for debugging        genomic feature descriptions derived from automated        analyses and computational pipelines It is also a tool to        facilitate connecting and comparing these annotations with        existing biological data As an introspective tool Apollo        makes it possible for researchers to closely examine and        compare explicit details and contrast them with their own        biological knowledge and apply any necessary corrections        This evaluation is absolutely essential for progress in        genomics for three reasons        First we must improve our current algorithms and        recognition techniques for proteincoding genes Several        groups have augmented standard approaches based solely on        proteincoding potential by exploiting exact alignments to        cDNA and EST data and similarities to sequences from the        same or different genomes see for example           However we are not yet at the stage where we can make        intelligent use of all the existing data automatically        Resolving the conflicts that exist between EST evidence        BLAST similarities and computational predictions can be        extremely complicated and is still best done by manual        inspection The simplifications that existing automated        annotation pipelines must make lead to a number of        systematic errors including under or overpredicting        genes as well as merging the exons from two genes in one        gene model or splitting the exons from one gene into two        gene models For example if the software discounts        unspliced EST evidence a common simplification made to        reduce the effect of errors in EST databases small genes        can easily be omitted In addition issues such as        determining alternative transcripts understanding promoter        usage identifying polyadenylation sites distinguishing        genes within the intron of another gene and recognizing        dicistronic genes are all outstanding problems in the        annotation of proteincoding genes Yet as more genomes        become available we cannot hope to provide a high level of        manual examination and correction to describe the genes        present on these genomes precisely It is essential that we        utilize the knowledge we are gaining from these initial        wellannotated genomes to improve the existing        computational methods both by generating more        comprehensive training sets as well as by refining the        algorithms themselves        Second we must expand the available computational        repertoire to include methods for annotating other        biologically important features Current computational        analyses are primarily only capable of describing simple        proteincoding gene models and these are therefore the sole        targets of most automated strategies There are other        useful predictive programs for tRNA genes   and        promoters      but a large number of        biological features still cannot be recognized by        computational methods alone For example there are no        fully automatic computational methods to detect        biologically important annotations such as pseudogenes and        noncoding RNA genes Until a day arrives when we know all        the feature types that we are searching for and precisely        how to find them in the genomic sequence we will need to        rely upon expert inspection to augment automated        analyses        Third we must deliver the annotations to the community        as quickly and as accurately as possible because the        annotations themselves are an important resource        Researchers depend on the availability of complete peptide        sets gene structures and other data Moreover to be truly        useful these data must be correct Many people have noted        and remarked upon the current fallibility of firstpass        proteincoding gene predictions and other annotations see        for example         The technology        is not yet available to provide highly reliable datasets        This impedes research that relies on these data If        researchers in the community were provided with a means of        viewing the supporting data for each annotation as well as        for making corrections to annotations then the accurate        data they require would become available much sooner                    Origins of Apollo        In the year  within the space of six months both        the         Drosophila genome   and the draft        human genome   were published Both the Berkeley        Drosophila Genome Project BDGP working with Celera        Genomics and other researchers and the Ensembl          project working on the human genome provided the community        with annotations in a very short time However to those        who were working closely with the data it was obvious that        in the longer term this initial analysis would have to be        refined improved and extended by manual curators The        genomics community required tools that would provide more        than simply a view of these data but that would enable        professional curators and ultimately every researcher to        easily modify and correct the annotations on an ongoing        basis through direct interaction Both FlyBaseBDGP          and Ensembl shared this understanding and in the summer of         entered into a collaborative agreement to achieve this        aim        Apollo has roots reaching back more than a decade and        builds on previous generations of software and domain        knowledge In the early s the         C elegans project was underway at        the Sanger Institute and the         Drosophila genome project was        beginning at Berkeley Both projects share the same        informatics root because both began by using ACeDB        documentation code and data available by anonymous FTP        from     Berkeley developed a variant called        FlyDB   and was actively involved in porting AceDB to        the Macintosh computer platform The Sanger Institute        coordinated the overall development of ACeDB and has relied        upon ACeDB for the ongoing annotation of         C elegans and human genome        sequence        In the mids first Perl   and then Java          were becoming widespread as programming languages for        developing bioinformatics tools Our groups explored the        use of both languages Berkeley created bioTkPerl           and became one of the early participants in BioPerI          BioTkPerl was used in a number of applications but most        notably in this context it was the underpinning for the        annotation tool Genotator   Genotator has been widely        distributed and in turn formed the basis for other        Perlbased genomic tools such as Genquire          Initially we had hopes that Java would enable us to        distribute both the data and the application software        dynamically over the internet and thus solve the problem        of providing a farflung community with both the freshest        data and the latest application releases simultaneously In        practice both the Berkeley and Ensembl groups use Perl for        internetbased data access   and Java for locally        resident applications Our first Java applications were        Artemis at the Sanger Institute   and CloneCurator at        Berkeley Artemis is widely used for annotating microbial        and other smaller genomes CloneCurator was used to        annotate the  million base Mb         Adh region of         Drosophila   and provided the        baseline that was used to evaluate the results of the        Genome Annotation Assessment Project   trial Although        both provided useful tools for the tasks they were        originally developed for we needed a more sophisticated        and easier to use annotation editor for a large complex        eukaryotic genome There have been two commercial products        that originated with CloneCurator and built upon its        intellectual legacy AnnotationStation Neomorphic Software        for TIGR and GenomeBrowser Celera but neither was        freely available Apollo is the most recent undertaking and        builds upon all of this accumulated experience        Several general concepts were learned over this period        as we gained experience in working with genomic sequence        data One was the importance of distinguishing the        presentation of the information from the underlying        biological data model Searls   stated this concept        most clearly as the need to drive semantics out of the        graphical presentation The second key concept was an        appreciation of wellunderstood and standard issues in data        management and portability We needed a graphical        annotation tool that could be used easily at multiple sites        with different datamanagement environments Taken        together these issues led to the development of        Apollo                    Overview of Apollo from the curatorial        perspective                  Viewing the data          The curator can load data by specifying a region on a          selected chromosome Depending on the source of the data          this region may be determined by absolute sequence          position a file name or for           Drosophila  gene name cytological          region map position scaffold accession or sequence          which will be mapped to a genomic location by BLAST          similarity After data from the desired region have been          loaded a navigation bar allows the user to easily access          other regions of the genome  for example the region          immediately upstream or downstream of the currently          displayed sequence Apollo can transparently access data          across the network from remote machines as well as          reading files that reside locally          The main Apollo screen shows genomic features layered          on a segment of DNA where each genomic feature appears          as a colored shape typically rectangles as shown in          Figure  Features are grouped meaning that the          separate local alignments of subsequences derived from          the same source sequence HSPs are treated as a single          composite feature and likewise the distinct exons from a          prediction are grouped together into a single feature          composite features are typically drawn as lines          connecting the rectangles representing member features          By default the display shows features on both the          forward and reverse strands with the forward strand on          top and the reverse strand on the bottom separated by a          coordinate bar For each strand the inner light blue          panel contains annotations showing exons and introns for          each transcript of a proteincoding gene The outer          gray panel displays computational evidence to support          these annotations such as gene predictions generated by          programs such as GenScan   and Genie   and other          biological data such as ESTs aligned using the program          Sim   and protein homologies revealed by BLASTX                     The features representing the supporting evidence in          the outer panel are organized into tiers and types A          tier is a horizontal row of supporting evidence placed at          a specified position on the vertical axis that can be          labeled and controlled as a single collection A tier          might be organized for example to contain all gene          prediction results from various programs or all BLASTX          results from comparisons to several different species          databases In addition to the tier each feature is          associated with a particular data type A feature type          is typically an association of that feature to the          results produced by a particular analysis for example          all features derived from a TBLASTX run against all mouse          ESTs in dbEST might be given the type Mouse Each data          type can be individually assigned a shape and a color          Figure  Users can control the maximum number of rows          shown in a tier and set a score threshold so that only          results above that threshold are visible Operations on          individual tiers include setting a vertical coordinate          position or setting whether the tier is visible or          hidden The user can view the data within a tier in a          collapsed style in which all features within a tier are          collapsed into one line Figure  or in an expanded          style in which each individual feature is positioned to          avoid overlapping any other feature These two organizing          principles of layout and category simplify viewing the          massive amounts of data          A feature can be selected by clicking on it at which          point detailed information such as name sequence range          and score appear in the text panel at the bottom of the          screen Figure  Rubberbanding regions allows one to          select multiple entries and view abbreviated information          about each in the text display table which can be sorted          by any field for example name or score          Further information about an annotation that is          locally maintained can be displayed by bringing up the          text window which contains descriptive information about          an annotation Figure  Many features originate from          other databases for example SWISSPROT   EMBL            and GenBank   and we can obtain extra          information by looking up those features in their parent          databases Apollo allows the user to access this          information using a contextdependent menu By          rightclicking a feature the relevant report is          retrieved and shown in an internet browser          Apollo allows the view to be scaled using zoom buttons          that magnify by    and  The          magnification can also be targeted to fit a selected          feature Apollo provides semantic zooming some          features that would clutter the display at low zoom          levels appear only when the user zooms in At a          sufficiently high zoom level start and stop codons and          the underlying genome sequence appear Likewise the          sequence level information is displayed for each evidence          type and annotation either as nucleotides or aminoacid          residues Figure           A view is also available that displays the translation          of each of the three frames of the genomic sequence In          this start and stop codon positions are colored green          and red respectively Also when a transcript is selected          the specified coding frame of each of its exons is          highlighted          In addition to the horizontal scroll bar curators can          move to a specific position by specifying a coordinate          gene name or short sequence string Figure  Users can          also bookmark genes of interest to find them easily          again The sequence of any feature or set of features can          be saved in FASTA format either as the raw DNA sequence          or as a virtual cDNA coding sequence or translated          aminoacid sequence Apollo also provides a restriction          enzyme finder which allows the user to find known          restriction enzyme sites within a sequence and a GC base          frequency analyzer which displays a plot of GC content          from an adjustable sliding window over a sequence          The most recent addition to Apollo is the synteny          viewer and editor Figures   which displays features          on two different genomes at the same time The need for          this additional tool was precipitated by the recent          release of the mouse genome The synteny display is being          used to improve annotations by closely examining the          mousetohuman comparisons We are currently working to          add editing capabilities to this view and to present          other genome comparisons such as between           Drosophila and           Anopheles                           Editing the data          Apollos editing functionality allows curators to          manually create and modify gene annotations Annotation          in Apollo is supported by the ability to detect and          display edge matches start and stop codons and potential          splice sites New gene models can be created easily by          dragging a feature from the evidence panel into the          annotation zone When a new gene model is created Apollo          automatically creates an annotation using the longest          possible open reading frame ORF for the transcript          Curator comments can then be attached to the gene          annotation or to an individual transcript annotation          Modifications are timestamped and associated with the          curators name providing a complete history of the          annotation          As alternatively spliced transcripts are added to a          gene model they are sequentially named and numbered to          associate them with that annotation Apollo automatically          creates alternatively spliced transcripts for a gene          whenever the ORFs of transcripts overlap In           Drosophila overlapping untranslated          regions UTRs are observed frequently between adjacent          transcripts but this does not necessarily indicate that          the transcripts are for the same gene so Apollo offers          the option to make these new transcripts into distinct          overlapping genes Curators may add exons to existing          transcripts by dragging the selected evidence down until          the features are positioned directly over an existing          transcript Curators may set a splice site by selecting          an exon and one evidence feature and choosing either the          Set as  end or Set as  end option from the          annotation popup menu          Sequencelevel adjustments are possible with Apollos          exon editor This allows the curator to modify          intronexon boundaries base by base split and merge          genes and export genomic or translated sequence The          exon editor Figure  allows one to view the genomic          sequence of a single strand and its threeframe          conceptual translation with start and stop codons          highlighted                            Overview of Apollo from the developers        perspective                  Installation and configuration          Apollo runs under the Windows Mac OS X Linux and          Solaris operating systems and requires Java  or           In our memory tests with a  kilobase kb sequence          with several thousand features the memory heap size          hovered around  Mbytes MB Therefore Apollo will run          on a machine with  MB of available memory but it will          do better with  MB          Apollo is highly configurable in terms of appearance          connectivity and extensions Users can specify the color          graphical representation and placement of any feature          both annotations and computational results The          configuration file describes both the tiers and the types          of data that are to be displayed The file describes each          tier by a label for example Prediction a visible          flag either true or false and a layout flag if true          then all data in this tier is arranged to avoid overlap          that is the tier is expanded The file also describes          for each feature type the tier it is to appear in a          label for that feature type a color the list of          attributes to appear in the tabular report initial score          thresholds and the drawable class to be used to display          this feature URLs for connecting features to outside          data sources are also configurable Note that the          separation of tiers and types allows multiple feature          types to be displayed in the same tier For example the          results of all geneprediction programs can be shown in a          single Prediction tier The aim is provide as much          flexibility as possible in the presentation of the data          The information included in this file is incorporated          when Apollo data are loaded          The user can change some of the style attributes of          a feature type  for example its color and tier position           interactively A types panel pops up as a separate          window and shows all the tier names and colors          Rightclicking on a type lets the user adjust the color          used for displaying features of that type middle          clicking allows the score threshold to be adjusted          features with scores below the threshold are not shown          in the display The user can adjust the order of tiers          by selecting and dragging tiers with the mouse and the          control key The new tier options can then be saved to a          tiers file allowing each user to store personal style          preferences                          External data adaptors connecting Apollo to a          database          Apollo is populated with data via a set of adaptors          Typically for data coming from an external data source          these consist of two Java classes a dialog box and the          adaptor itself The dialog box allows the user to tell          the system what sequence they wish to examine The          adaptor provides a method for translating between the          structure of the external data and the internal Apollo          data models          The existing adaptors allow data to be loaded from the          Ensembl CGI server GAME XML files direct connections to          either the Ensembl or Gadfly databases DAS servers            and the Ensembl variant of GFF Once edited the data          may be stored as GAME XML files GFF files or GenBank          table format   We recognize a need for additional          adaptors to read other variants of GFF particularly that          generated by Artemis and GenBank and EMBL flatfile          entries          The class ApolloguiDataLoader manages the fetching          and recording of annotation session data which are held          in the CurationSet data model This class is instantiated          whenever a new request is received for an additional          feature or sequence data from an external source The          DataLoader class is quite straightforward it provides          two publicly available methods for loading and saving the          data utilized during an annotation session If a specific          data adaptor is not provided among the arguments in the          initial request then the DataLoader will bring up a          dialog box orgbdgpswingwidgetDataAdapterChooser to          allow the user to select an adaptor for an external data          source or sink When the DataLoader instantiates a          DataAdapterChooser it provides it with an          orgbdgpioDataAdapterRegistry This DataAdapterRegistry          is populated with the list of all available adaptors from          the configuration file and is initialized during Apollos          startup These adaptors are one of the two pieces of          software that must be provided to add a new external          adaptor          A data adaptor extends the          orgbdgpioAbstractDataAdapter class and implements the          following methods of the ApolloDataAdapterI          interface                    GetUI The DataAdapterChooser          requires an interface to interact with the user and          collect any necessary information The DataAdapterChooser          obtains this interface via this DataAdapter method          including as an argument the type of inputoutput          operation for example IOOperationREAD or          IOOperationWRITE This user interface is the other          class in addition to the DataAdapter itself that the          software developer must provide to add an external          adaptor                    GetCurationSet his returns a          CurationSet model from which all annotations and          features can be accessed A CurationSet is the hub for          all sequence and feature models contemplated in an          annotation session                    CommitChanges The argument passed to          this is a CurationSet The purpose is to record the          curators annotation in a persistent form whether this          is a file or a database                    GetStateInformation Following a load          this method captures the current query parameters so that          they may be saved and then restored in subsequent          sessions                    setStateInformation This method          restores the parameters needed to access a CurationSet          that was under examination in an earlier session It is          an alternate to explicitly setting load parameters using          a dialog          There are other required methods as well but those          described above provide the essential functionality for a          DataAdapter          The explicit DataAdapterUI that must be written          provides an implementation of the          orgbdgpswingAbstractIntDataAdapUI interface It          provides the DataAdapter with any user information that          is entered into the dialog window The key method is          doOperation which performs the data transformation by          delegating it to its partner data adaptor The input and          outputs to this method are entirely dependent on the          operation the data adaptor is supposed to perform          In summary the mechanics of adding a new external          data source are straightforward This allows a developer          to focus solely on writing the software to handle the          semantic mapping between their own data representation          and the Apollo data models                          Adding new Drawables          Several graphical elements are already available for          representing features Figure  Developers can          incorporate new Drawable classes by simply extending the          existing base classes and implementing relevant methods          The following describes some of the methods that can be          overridden                    DrawSelected drawUnselected  or          simply           draw  These methods actually paint          the graphics for the primary representation of the          sequence                    AddHighlights can be used to draw          graphical indications that a feature shares start or end          positions with other features on the sequence                    AddDecorations is used to draw any          additional characteristics for example the sites of          start and stop codons within the feature          A single feature type in fact requires two Drawable          classes one for a set of those features and another for          an individual feature This is useful for drawing gene          structures because the draw method for the set can be          used to draw a single line to illustrate the introns          whereas the draw method for the individual exons can be          used to draw the rectangles to illustrate the exons Once          a developer has written the Drawable software it can be          added by including the name of the class in the          configuration file                          Adding new views          This is undoubtedly the most ambitious way of          extending Apollo A developer must understand how events          are passed between windows because it is these events          that indicate some change has occurred in the state of          the shared underlying data models While there are many          other steps that are involved in adding a new view this          section will focus on crucial elements of event handling          inside Apollo          Windows that are interested in receiving a particular          type of event must implement the appropriate listener          interface for that event When the listening window is          instantiated it is provided with the central Controller          object and must add itself to the global list of          listeners held in the Controller object by calling the          Controllers addListener method with itself as the only          argument When the Controller receives notification of a          particular event it notifies every listener on this          list          Events themselves are provided to the central event          Controller The Controller implements an individual          handler method for every type of event within Apollo          These Controller handler methods notify all registered          Listeners that an Event of that type has occurred Some          examples of the current list of events for broadcasting          changes involving feature and sequence selection          movement to a different sequence position changes to          feature content or appearance window operations and the          availability of new data are briefly described below                    Feature selection This is the most          basic of events and indicates that one or more of the          sequence features has been selected usually by a mouse          click but also from the text search dialog menus and          scrolling lists                    Base focus This event is used to          center a display of the genomic sequence on a particular          base This may be used to position a display on a          feature or because a user has typed in a particular          position or because a given sequence string occurs at          that position                    Region change This event indicates          that a completely new region of the genome is replacing          the current sequence                    Annotation change The          AnnotationEditor is the sole generator of these events          To track changes to these important features and ensure          consistency this task is highly centralized Thus for          example when editing from the synteny view the          modification requests will be relayed to the          AnnotationEditor While the user interacts with the          synteny display the nongraphical AnnotationEditor class          directly manages the edits The AnnotationEditor carries          out the additions deletions and changes to start and end          positions for exons transcripts genes and any other          annotation features The Controller then passes these          events on to the listeners so that the annotations can be          redrawn accordingly                    Result change This event is used          only under unusual circumstances Features are          occasionally placed on the incorrect strand because of          problems the alignment software has in identifying the          correct strand EST sequences that do not contain any          splice junctions are the common source of this problem          In these cases we allow the curator to move the computed          feature from one strand to the other so that it may be          used during annotation                    Appearance change This event is used          to issue a request for a change in the appearance of a          feature for example if the chosen color is altered                            Discussion        Apollo was first put into practical use as an editor in        November  for the reannotation of the complete         Drosophila genome Ten fulltime        curators located at two sites FlyBaseBDGP and        FlyBaseHarvard used Apollo over the course of seven        months to revise and correct the annotations for the        complete genome   During the course of this exercise        many improvements and capabilities were made to the        software culminating in a wellexercised codebase for        Apollo The Ensembl group provides Apollo to the community        for browsing human and mouse annotations        Other groups both commercial and academic are also        using Apollo The bioinformatics group at Biogen has been        using Apollo to examine alignments executed with BLAT        between their internal data and the public human genomic        sequence X Zhijun personal communication Their group        wrote a custom data adaptor to load their data that uses        either chromosome and range or a sequence or a sequence        name to query their internal data source and then display        the specified region in Apollo The data adaptor retrieves        the data from an internal web service The         Fugu genomics group at the UK HGMPRC        in Cambridge has been using Apollo to display scaffolds        that is draft sequences of the         Fugu genome T Vavouri personal        communication Annotation has been generated in GFF format        and loaded into Apollo The         Fugu group is currently working on        modifying Apollo to enable the interactive manipulation and        validation of the ordered scaffolds        The best annotation makes use of every available piece        of information This has already been seen in the         Drosophila projects use of results        from external pipelines and of the internal sequence reads        individual sequences from the cDNA that are unassembled        available from the fulllength cDNA sequencing project          As new data become available Apollo must be able to        display them effectively Today this means we need to add        displays to Apollo that exploit comparative data By        aligning the genomic regions of related species and looking        for conserved sequence regions we will gain insight into        both fine gene structure by identifying microexons and        into regulatory and other conserved regions        Motivated both by our experience over the past several        months and by new data that are becoming available we are        actively working on the following new features A splice        junction view and editor will provide a tabular view of        donor and acceptor splice pairs together with predicted        splice junctions from standard weight matrices   It        will allow curators to finetune splice sites to generate        the most biologically likely peptide Data adaptors for        GenBank and EMBL flat files should be particularly useful        for a broader audience of biologists In addition we will        allow existing entries from these public sequence archives        to be overlaid onto the genomic sequence that is being        annotated        Finally we have developed external analysis adaptors        which will be useful in two ways First they will enable        the curator to dynamically reanalyze a specific subsection        of the sequence This is important because despite best        efforts the results of a gene prediction or an alignment        over a large genomic region are often not as accurate as        those produced when the sequence analysis is more targeted        Second ondemand analysis will allow the curator to        dynamically evaluate the peptides generated by        proteincoding genes This peptide evaluation is essential        to the process of annotation if one wishes to produce a        highquality peptide set The annotated peptides must be        examined to verify their biological fidelity This includes        both consideration of the motifs that are present on the        peptide and a comparison with known peptides Downstream        processing currently carries out this validation of the        annotations in bulk but this delays feedback and problems        with the peptides are only cycled back to the curators for        correction after some time has passed Making corrections        will be much more effective once the results of the        evaluation are immediately available to the curator while        they are working with that gene        There are many other features that could be added to        Apollo and we look forward to working with the open source        community in bioinformatics to develop Apollo further The        Generic Model Organism Database project GMOD   whose        aim is to provide tools for managing organism databases        has adopted Apollo as its annotation workbench Software        developers who are interested in contributing to this        project and customizing Apollo for their own genome        annotation projects can find more details at   and can        obtain the source code from the Concurrent Versions System        CVS   repository maintained on the GMOD Sourceforge        site at   Biologists who are interested in using        Apollo for genomic annotation will find the detailed users        guide at   and the most recent release of Apollo for        local installation at              