                    Background        Accurate computational protein function analysis is an        important way of extracting value from primary sequence        data Due to the large amount of data automated systems        seem unavoidable at least for initial prioritizing        steps Such efforts are complicated for a variety of        reasons Many proteins belong to large families as        suggested by Dayhoff     Such families are often        composed of subfamilies related to each other by gene        duplication events For example Ingram    showed that        human   and  chains of hemoglobins are related to each        other by gene duplications Gene duplication allows one        copy to assume a new biological role through mutation        while the other copy preserves the original functionality             Hence subfamilies often differ in their biological        functionality yet still exhibit a high degree of sequence        similarity        Other complications in functional analysis include        ignoring the multidomain organization of proteins error        propagation caused by transfer of information from        previously erroneously annotated sequences insufficient        masking of low complexity regions and alternative splicing                   Typically automated sequence function analysis relies        on pairwise sequence similarity and programs such as BLAST           or FASTA     Annotating a sequence by        transferring annotation from its most similar sequences        tends to produce overly specific annotation In contrast        analyses using profile search algorithms such as HMMER        httphmmerwustleduand Pfam    classify sequences        too generally They recognize that a query sequence belongs        to a certain family or to be more precise indicate which        domains the query is likely to contain but do not        subclassify the sequence        At least two scenarios can cause misleading predictions        when using pairwise sequence similarity alone for        annotation i not having a known annotated representative        of the correct subfamily because incomplete sequence        databases andor gene loss Figure  and ii unequal        rates of evolution Figure  The case of trying to        annotate the first or only representative of a novel        subfamily is of particular interest Pairwise similarity        based methods alone cannot recognize that a new sequence        does not belong in any currently known subfamily eg        orphan Gprotein coupled receptors because every        sequence is most similar to something In contrast when        constructing a phylogenetic tree this case is easy to        observe as illustrated in Figure  A human annotator can        use phylogenetic tree analysis to place a new sequence in        the subfamily structure of a gene tree of known sequences        This approach was called phylogenomics by Eisen            It would be desirable to automate this procedure but the        best automated methods for subfamily annotation such as        the COGs database     are clustering methods that do        not directly use phylogenetic analysis        It is infeasible to completely automate functional        analysis because it is impossible to precisely define what        protein function means However a principle of        phylogenomics is that orthologous sequences that diverged        by speciation are more likely to conserve protein function        than paralogous sequences that diverged by gene        duplication Orthology and paralogy are well defined and        can be inferred from gene and species trees One useful and        automatable phylogenomics approach would be as follows if        a novel sequence has orthologs annotation can be        transferred from them as in best BLAST analysis if there        are no orthologs the sequence is classified as just a        family member as in PfamInterPro analysis and flagged as        possibly the first representative of a novel subfamily At        the core of such approaches stands therefore the        distinction between orthologs and paralogs and hence the        ability to discriminate between duplication and speciation        events on a gene tree Various efficient algorithms to        infer gene duplications on a gene tree by comparing it to a        species tree have been described for example by        Eulenstein     and by Zhang     We developed a        simple algorithm named SDI for Speciation Duplication        Inference that appears to solve this problem even more        efficiently on realistic data sets though it has an        asymptotic worstcase running time that is less favorable                   In practice phylogenetic trees are unreliable Errors        in trees will produce spurious inferred duplications This        is obviously problematic if duplications are to be used as        indicators of potential functional changes Therefore        instead of determining the orthologs of a query sequence on        just one gene tree inference could be performed over        bootstrap resampled gene trees     to estimate of the        reliability of the assignments Here we describe and test a        procedure  RIO for Resampled Inference of Orthologs         which allows to perform such analyses in an automated        fashion We present results of using RIO to analyze a plant                 A thaliana     and an animal        the nematode         C elegans     proteome                    Algorithm                  Definitions          Orthologs are defined as two genes that diverged by a          speciation event Paralogs are defined as two genes that          diverged by a duplication event     Other concepts          derived from gene trees can be useful for functional          prediction We introduce and justify three such concepts          superorthologs ultraparalogs and          subtreeneighbors          Careless use of orthology relationships without          examining the tree itself can lead to incorrect          annotations In the example shown in Figure A the human          query sequence has two orthologous sequences in wheat          These two wheat sequences are related to each other by a          gene duplication and one or even both of them might          have undergone functional modification after their          divergence Given a procedure that gave a list of          orthologues for the human gene query such situations          should be revealed by only partial or complete absence          of agreement between the annotations of the wheat          orthologs Now consider the situation in Figure B This          is trickier since in this case only one ortholog will be          reported for the query sequence but it will be just as          dangerous to transfer annotation We do not attempt to          solve this problem the solution is careful manual          analysis of the gene tree but an automated procedure can          warn that this situation might be present For this          purpose we introduce the concept of          superorthologs                    Definition  Given a rooted gene          tree with duplication or speciation assigned to each of          its internal nodes two sequences are superorthologous          if and only if each internal node on their connecting          path represents a speciation event          Hence the query sequences in Figure have no          superorthologs In contrast the rat mouse and wheat          sequences in Figure Aare superorthologs pf the human          query sequence By definition the superorthologs of a          given sequence are a subset of its orthologs          Certain sequences underwent multiple recent          duplications resulting in large species specific          sequence families such as the           C elegans seventransmembrane          proteins acting as odorant and chemosensory receptors               For query sequences belonging to such sequence          families orthologs if present are less effective for          predicting specific information In these cases paralogs          of the same sub family might be more informative for          functional prediction as long as the duplications indeed          happened late in evolutionary times To formalize          this we introduce the concept of ultraparalogs                    Definition  Given a rooted gene          tree with duplication or speciation assigned to each of          its internal nodes two sequences are ultraparalogous if          and only if the smallest subtree containing them both          contains only internal nodes representing          duplications          Figure illustrates the concept of ultraparalogs It          follows from definition  that two ultraparalogous          sequences must occur in the same species          Often researchers construct a gene tree and then          informally use subtrees clades to make inferences          about sequences without regard to duplications and          speciations We introduce this concept into our          procedure as well formalized as subtreeneighbors          illustrated in Figure                     Definition  Given a completely          binary and rooted gene tree the           k subtreeneighbors of a sequence           q are defined as all sequences          derived from the           k level parent node of           q  except           q itself the level of           q itself is            q s parent is  and so          forth          Subtreeneighbors can be useful if there is partial          agreement among their annotations for example if the          subtreeneighbors of a query are NAD dependent          isocitrate dehydrogenase and NADP dependent isocitrate          dehydrogenase we can suppose that the query is likely to          be a isocitrate dehydrogenase but it is not possible to          determine whether it is dependent on NAD or NADP  If          the subtreeneighbors lack any agreement in their          annotations a useful inference is not possible see             for a more detailed discussion Furthermore orthologs          that are not also subtreeneighbors can be misleading          for a more detailed discussion of this see below and          see Figures and for examples                          The RIO procedure          This basic RIO procedure is as follows For a simple          example with only four bootstrap resamples see Figure                    We use the Pfam protein family database    as a          source of high quality curated multiple sequence          alignments and profile HMMs Hidden Markov Models see             for a review as well as programs from the HMMER          package httphmmerwustledu RIO can easily be          adapted to work with different sources of alignments and          different alignment programs For tree reconstruction          the neighbor joining NJ algorithm    is used since          it is reasonably fast can handle alignments of large          numbers of sequences and does not assume a molecular          clock NJ recreates the correct additive tree as long as          the input distances are additive     and is          effective even if additivity is only approximated                                 Input A query protein sequence           Q with unknown function          A curated multiple alignment           A from the Pfam database for the          protein family that           Q belongs to as determined by          hmmpfam from the HMMER package          A profile HMM           H for the protein family that Q          belongs to                    Output A list as in Figure  of          proteins orthologous to           Q  sorted according to a bootstrap          confidence value based on orthology superorthology or          subtreeneighborings          Optional A gene tree based on the multiple alignment           A and the query           Q annotated with orthology          bootstrap confidence values for the query           Q                       Procedure                                Query sequence           Q is aligned to the existing          alignment           A using hmmalign from the HMMER          package and the Pfam profile HMM           H                      The alignment is bootstrap          resampled           x times usually           x                       Maximum likelihood pairwise          distance matrices are calculated for each of the           x multiple alignments using a model          of amino acid substitution for example BLOSUM    or          Dayhoff PAM                         An unrooted phylogenetic tree is          inferred for each of the           x multiple alignments by neighbor          joining     resulting in           x gene trees Each tree is rooted          by a modified version of our SDI algorithm    that          minimized the number of duplications postulated this is          discussed in more detail later                     For each of the           x rooted gene trees For each node          it is inferred whether it represents a duplication or a          speciation event by comparing the gene tree to a trusted          species tree                     For each sequence           s in the gene tree except           Q  Count the number of gene trees          where           s is orthologous to           Q see Figure for an illustration          of steps  and  Bootstrap confidence values for          superorthologies ultraparalogies and subtreeneighbors          are calculated analogously                          Precalculation of pairwise distances for increased          time efficiency          The most time consuming step in the procedure          described above is the calculation of pairwise distances          The time complexity is O           xLN            N being the number of sequences           L being their length and           x being the number of bootstrap          resamples On an average Intel processor the wall clock          time for  bootstrapped datasets of a typical Pfam          multiple alignment is in the range of hours          Since the query sequence is aligned to stable Pfam          alignments it is possible to precalculate the pairwise          distances for each alignment and store the results Then          when RIO is being used to analyze a query sequence only          the distances of the query to each sequence in the Pfam          alignment have to be calculated This step becomes thus          O           xLN  instead of O           xLN           To do this correctly the aligned query sequence has          to be bootstrap resampled in exactly the same way as was          used for precalculating the pairwise distances of the          Pfam alignment For this purpose bootstrap positions          eg which aligned columns from the Pfam alignment were          chosen in a particular bootstrap sample are saved to a          file With this file it is possible to bootstrap the new          alignment of N sequences Pfam alignment plus query          sequence in precisely the same manner so the NxN          precalculated distances are valid for the NxN          distance matrix The alignment method must also guarantee          that the original Pfam multiple alignment remains          unchanged when the query sequence is aligned to it This          requires specially prepared Pfam full alignments and          profile HMMs that are created with the HMMER software as          follows                    Input Original Pfam full alignment           A                     Output aln file containing          RIOready full alignment          hmm file containing a RIOready profile HMM          nbd file containing pairwise distances          bsp file bootstrap positions file          pwd file containing pairwise distances for bootstrap          resampled alignment                     Remove sequences from species not          in RIOs master species tree from alignment           A  If           A does not contain enough sequences           abort                     Run hmmbuild o A on           A  using the same options as were          used to build the original Pfam HMM for           A  resulting in alignment           A  HMMERs construction          procedure slightly modifies the input alignment in ways          that are usually unimportant but which matter to          bootstrapping in RIO Keep A as the aln file                     Run hmmbuild with hand option          on           A  resulting in HMM           H using the same options as were          used to build the original HMM for           A  Calibrate           H with hmmcalibrate and keep as          hmm file                     Remove nonconsensus insert          columns from           A these are annotated by HMMER          resulting in alignment           A                      Calculate pairwise distances for           A  resulting in the nbd file          nonbootstrapped distances                     Bootstrap resample the columns of           A  resulting in the bsp file          bootstrap positions file                     Calculate pairwise distances for          bootstrapped           A  resulting in the pwd          file                          Rooting of gene trees          The concept of speciation and duplication is only          meaningful on rooted gene trees but the neighbor joining          algorithm infers unrooted trees We use a simple          parsimony criterion for rooting Gene trees are rooted on          each branch resulting in            N  differently rooted trees for a          gene tree of           N sequences For each of these the          number of inferred duplications is determined From the          trees with a minimal number of duplications if there is          more than one the tree with the shortest total height is          chosen as the rooted tree Empirical studies on gene          trees based on  Pfam alignments show that about           of trees rooted in such a way have their root in the same          position that direct midpoint rooting    would place          it          Naively performing a full duplicationspeciation          analysis on each of            N  differently rooted trees          results in a overall time complexity of O           N  or worse but this can be          avoided For the purpose of the following discussion it          is assumed that our SDI algorithm for          speciationduplication inference is employed but the          idea applies to all algorithms based on a mapping          function M defined as follows                        Definition  Let           G be the set of nodes in a rooted          binary gene tree and           S the set of nodes in a rooted          binary species tree For any node           g            G  let             g  be the set of species in which          occur the extant genes descendant from           g  For any node           s            S  let             s  be the set of species in the          external nodes descendant from           s  For any           g            G  let M           g             S be the smallest lowest node in           S satisfying             g    M           g           Duplications are then defined using M           g  as follows                    Definition  Let           g            and           g            be the two child nodes of an          internal node           g of a rooted binary gene tree           G  Node           g is a duplication if and only if          M           g   M           g             or M           g   M           g                      The main task of most algorithms for duplication          inference is the calculation of M After M has been          calculated for any rooted gene tree           G it is possible to explore          different root placements without having to recalculate M          for every node of           G  As long as the root is moved          one node at the time M has to be recalculated only for          two nodes the one node which was child  if the new          root is placed on a branch originating from child  of          the previous root or child  otherwise of the previous          root as well as for the new root itself Hence two          postorder traversal steps child  or  of the old root          then the new root in the SDI algorithm are all that is          needed The new sum of duplications is determined by          keeping track of the change in duplicationspeciation          status in the two recalculated nodes as well as in the          previous root Performing this over the whole gene tree          some nodes will be visited twice it is possible to          explore all possible root placements and calculate the          resulting duplications in practically linear time The          pseudocode algorithm is as follows                          Algorithm for speciation duplication inference          combined with rooting                    Input  binary gene tree           G  rooted binary species tree           S                     Output           G with duplication or          speciation assigned to each internal node and rooted in          such a way that the sum of duplications is minimized                      SDIunrootedG S                     root gene tree           G at the midpoint of any          branch          set           B  getBranchesInOrder           G           SDIse           G            S  see              for each branch           b in           B           set           n             child  of root of           G           set           n             child  of root of           G           root           G at the midpoint of branch           b           updateM           n                       n                       G           if sum of duplications in           G            d           min           set           d           min            d           set           G           dmin            G           return           G           dmin                       updateM             n                           n                           G                      set           r  root of           G           if child  of           r            n             child  of           r            n                      calculateMforNode           n                      else          calculateMforNode           n                      calculateMforNode           r                       calculateMforNode             n                      if            n  external          set           a  Mchild  of           n           set           b  Mchild  of           n           while            a            b           if            a            b           set           a  parent of           a           else          set           b  parent of           b           set M           n             a           if M           n   Mchild  of           n   M           n   Mchild  of           n                     n is duplication          else                    n is speciation                      getBranchesInOrder             G                      set           n  root of           G           set           i            while            n  root  indicator of           n            if            n  external  indicator          of           n            if indicator of           n            set indicator of           n            set           n  child  of           n           else          set indicator of           n            set           n  child  of           n           if parent of           n  root          set B            i   branch connecting           n and parent of           n           else          set B            i   branch connecting child  of          root and child  of root          set           i            i            else          if parent of           n  root            n  external          set B            i   branch connecting           n and parent of           n           set           i            i            set           n  parent of           n           return           B                           Master species tree          Duplication inference requires a species tree For          this purpose a single completely binary master species          tree was compiled manually containing  of the most          commonly encountered species in Pfam spanning Archaea          Bacteria and Eukaryotes This tree is based mainly on          information from Maddisons Tree of Life project          httptolweborgtreephylogenyhtml NCBIs taxonomy          database          httpwwwncbinlmnihgovTaxonomytaxonomyhomehtml          the Deep Green project          httpucjepsberkeleyedubryolabgreenplantpagehtml          and        This master tree groups nematodes          and arthropods into a clade of ecdysozoans molting          animals as proposed by Aguinaldo     a          classification which is still controversial The tree is          available in NHX format    at          httpwwwgeneticswustledueddyforestertreeoflifebinnhx                            Implementation        RIO is implemented in a Perl pipeline of several        software programs as follows Alignment of the query        sequence is done programs from the HMMER package        httphmmerwustledu Bootstrapping is performed by a        bespoke C program Maximum likelihood pairwise distances        are calculated using BLOSUM matrices    by a modified        version of TREEPUZZLE     Neighbor joining trees are        calculated by a modified version of NEIGHBOR from the        PHYLIP package           httpevolutiongeneticswashingtoneduphyliphtml        Rooting and duplication inference are accomplished by        SDIunrooted  a Java implementation of our SDI algorithm        which incorporates various methods for rooting see above        The actual counting of orthologs is performed by methods of        the Java class RIO These programs with the exception of        HMMER are part of the FORESTER package and are available        under the GNU license at        httpwwwgeneticswustledueddyforester        In order to run RIO locally the following packages and        databases need to be present HMMER the Pfam database            the SWISSPROT and TrEMBL databases            RIO is also available as an analysis webserver at        httpwwwriowustledu The pairwise distance and tree        calculations are parallelized in this version currently        ten  GHz Pentium III processors are being used                    Results and Discussion                  Precalculation of pairwise distances          Pairwise distances to be used in RIO analyses were          calculated using the full alignments as opposed to the          smaller curated seed alignments from Pfam  August            families     Sequences from species not          present in the master species tree were removed from the          alignments For computational efficiency reasons          alignments that still contained more than  sequences          were further pruned sequences not originating from          SWISSPROT were discarded and sequences from certain          mammals were excluded mouse rabbit hamsters goat all          primates except human since mammals are likely to be          oversampled in most Pfam families For some extremely          large families immunoglobulin domain PF protein          kinase domain PF collagen triple helix repeat          PF and rhodopsintype  transmembrane receptor          PF all mammalian sequences except those from          human and rat were excluded          Alignments of average length  amino acids           for zinc finger domains or with  sequences          were not analyzed because of lack of phylogenetic          signal For all other families pairwise distances for           bootstrap samples were prepared Following the above          rules pairwise distances were precalculated for           alignments from a total of  in Pfam            alignments were too short and  alignments contained          less than six sequences from species in the master          species tree                          Phylogenomic analyses of the A thalianaand C          elegansproteomes          In order to get an estimate of the effectiveness of          this implementation of automated phylogenomics we used          the RIO procedure to analyze the           A thaliana    and           C elegans    proteomes          The input for RIO consists of a query protein sequence          together with a Pfam alignment for a protein family that          the query belongs to Before RIO could be applied we          therefore had to determine the matching domains for each          protein in the           A thaliana and           C elegans proteomes For proteins          composed of different domains a RIO analysis is          performed for each domain individually          The source for protein sequences were          ATHpep a flatfile database of            A thaliana amino acid sequences          hypothetical predicted and experimentally verified          that have been identified as part of the Arabidopsis          Genome Initiative AGI          httpwwwarabidopsisorginfoagihtml and wormpep           a flatfile database of            C elegans amino acid sequences          httpwwwsangeracukProjectsCeleganswormpep          The program hmmpfam version  g from the HMMER          package was used to search each protein sequence in          ATHpep and wormpep  against Pfam  Only          domains with a score above the socalled Pfam gathering          cutoff were reported cutga option in order to          include only confident domain assignments          The sum of domains assigned to the            A thaliana protein sequences was           counting multiple copies of the same domain in          one protein as one  sequences matched one domain          containing possibly multiple copies of this one domain           sequences matched two different domains containing          possibly multiple copies of both  sequences matched          three or more different domains containing possibly          multiple copies of each Therefore a total of            sequences from ATHpep could be assigned          to one or more Pfam families          Similarly a sum of  domains was assigned to the                     C elegans protein sequences           sequences matched one domain  matched two different          domains and  matched three or more different domains          Thus   sequences from wormpep  could be          assigned to one or more Pfam families          RIO was then used to analyze each protein sequence          matching one or more Pfam families The results from          these analyses can be found at          httpwwwgeneticswustledueddyforesterrioanalyses          The approximate time requirement was between two and          three weeks performed on eight Pentium III  Mhz          processors                          How many sequences can be analyzed with RIO          The first question we asked was simply how many          sequences can be analyzed with RIO For an overview see          Table  From the            A thaliana domain sequences          matching a Pfam family   could be analyzed          with RIO using the precalculated distances            domain sequences were not analyzed because the          corresponding Pfam alignments were either too short or          did not contain enough sequences as described above            domain sequences were not analyzed because the          Evalue for the match to their profile HMM was below the          threshold of  This represents a second filtering          step for preventing analyzing false domain assignments          besides only analyzing domain sequences which score          above the gathering cutoff in the domain analysis RIO          performs a preprocessing step before aligning the query          sequence to a Pfam alignment in which the program          hmmsearch is used to trim the query sequence by searching          it with the appropriate profile HMM If the resulting          Evalue was below  no analysis was performed          Multiple copies of the same domain in certain sequences          result in a sum of individual analyses larger then the          number of analyzed domain sequences In case of           A thaliana this number was                    Correspondingly from the            C elegans domain sequences          matching a Pfam family   could be analyzed          with RIO using the precalculated distances            domain sequences were not analyzed because the          corresponding Pfam alignments were either too short or          did not contain enough sequences   domain          sequences were not analyzed because the Evalue for the          match to their profile HMM was below the threshold of           In addition we did not analyze the            C elegans sequences matching the          immunoglobulin family PF because we considered          the phylogenetic signal in this alignment to be          questionable Furthermore most of the  sequences          contain multiple copies of the immunoglobulin domain for          example CE contains  immunoglobulin domains and          we therefore worried that the results from this family          might skew our overall results The sum of RIO analyses          was           Thus a little less than half of each proteome can be          analyzed by RIO The most important factor is whether a          protein sequence has a match to a Pfam domain family                          RIO analysis of lactatemalate dehydrogenase family          members          In order to test whether RIO performs well on an          easy case RIO was used to analyze lactatemalate          dehydrogenase family members both in           A thaliana and           C elegans  LLactate and malate          dehydrogenases are members of the same protein family          represented in Pfam as ldh for the NADbinding domain          and ldhC for the alphabeta Cterminal domain yet they          catalyze different reactions Llactate dehydrogenase EC           catalyzes the following reaction Slactate           NAD  pyruvate  NADH     Malate dehydrogenase          NAD EC  catalyzes Smalate  NAD           oxaloacetate  NADH     NADPdependent malate          dehydrogenase EC  utilizes NADP as cofactor          instead of NAD       According to the Pfam domain          analysis described above the           A thaliana proteome contains ten          lactatemalate dehydrogenase family members whereas the           C elegans proteome contains three          In addition           C elegans also contains two          putative members of a second lactatemalate dehydrogenase          family     ldh which are not discussed here The          RIO output for the           A thaliana protein FM          analyzed against the ldh domain alignment is shown as an          example in Figure  The results are summarized in Tables          and  Complete RIO output files as well as NHX             tree files are avaliable herefor           A thaliana and at herefor           celegans  In all cases          distinction between malate dehydrogenase NAD and          lactate dehydrogenase is unquestionable and in accordance          with existing annotations and BLAST results irrespective          which domain ldh or ldhC was used for the RIO analysis          which implies that no domain swapping occurred over long          evolutionary times Furthermore the same results are          achieved whether only the top  sequence the one with          the highest orthology value shown in Tables and  or          the top  sequences are used to transfer annotation          from The only likely NADPdependent malate dehydrogenase          is the           A thaliana sequence MCK For          some query sequences the top orthology values are low          Yet all subtreeneighborings above  exhibit consensus          at distinguishing between malate and lactate          dehydrogenase In contrast a finer distinction eg          between mitochondrial and cytoplasmic malate          dehydrogenase proves more problematic While there is no          case of actual conflict between the existing annotation          and the RIO results in many cases there is no compelling          evidence in the RIO results to confirm the finer          distinctions in the existing annotations Obviously the          resolution power of RIO is limited by the given          annotations and by the number or even presence of          sequences for each subsubfamily                          Sequences with no orthologs in the current          databases          Next we determined the distribution of the top          orthology bootstrap values The sequence with the top          orthology bootstrap value is the one that is most likely          to be the true ortholog of the query If the top          orthology bootstrap value is low then the query sequence          is likely to have no ortholog in the Pfam alignment          These results are summarized in Table  For example for                     A thaliana query sequences at          least one sequence was orthologous in at least  out of           resampled trees In contrast for            A thaliana query sequences no          sequence was orthologous in more than five out of           bootstrapped trees For query sequences with more than          one copy of the same domain each copy had to meet the          conditions individually in order for the whole query          sequence being counted to be below or above the          threshold          We do not think it is possible at this stage to          determine reliable threshold values for true orthologs          or absence of orthologs Such thresholds are very          likely to be different for different Pfam families since          families vary in the phylogenetic signal their alignment          contains Some sequences that are very likely to be true          orthologs nonetheless exhibit marginal orthology          bootstrap values in the range of  or even lower          We focused on sequences that appeared to have no          orthologs  bootstrap since these would be cases          where a RIO analysis might be most able to correct overly          specific annotations that might be transferred based          solely on sequence similarity as illustrated in Figure           An example for this is the           A thaliana sequence FP          Files related to this analysis are avaliable here          This sequence is a zincbinding dehydrogenase Pfam          adhzinc PF FP has been annotated in          ATHpep as putative cinnamylalcohol          dehydrogenase based on sequence similarity its top           BLAST matches are all cinnamylalcohol dehydrogenases          with Evalues in the range of  if analyzed against          all nonredundant GenBank CDS          translationsPDBSwissProtPIRPRF on Jan            Cinnamylalcohol dehydrogenase EC  catalyzes          the following reaction cinnamyl alcohol  NADP           cinnamaldehyde  NADPH but it can also act on coniferyl          alcohol sinapyl alcohol and coumaryl alcohol in the          flavonoid stilbene and lignin biosynthesis pathways               According to the RIO analysis FP has no          orthologs see Figure for the corresponding tree and          Figure for the RIO output Furthermore its          subtreeneighbors above  cinnamylalcohol          dehydrogenases and NADPdependent alcohol dehydrogenases          EC  exhibit only partial annotation agreement          namely that of some type of NADPdependent alcohol          dehydrogenase but not EC  or EC           Hence FP is likely to be a possibly novel type          of NADPdependent alcohol dehydrogenase other than EC           possibly a novel type of cinnamylalcohol          dehydrogenase          One might expect that each query sequence that appears          to have no orthologs is connected with scenario similar          to the one described above for FP Yet this is          clearly not the case for the following reasons i Gene          duplications might not be followed by functional          modification many Pfam families are composed of          sequences which have all the same function at least at          the resolution of the current annotation ii Some Pfam          families are composed solely of sequences originating          from closely related or the same species such as          PF the B DNA binding domain of higher plants For          such families query sequences from the same species          group are expected to have low orthology values In such          cases the concept of subtreeneighbors and ultraparalogs          is more useful than orthologs iii Erroneous RIO          results caused by an insufficient phylogenetic signal          due to short sequences for example can lead to low          orthology values For this reason RIO also outputs the          average bootstrap value for the consensus tree to give          the user a hint about the amount of phylogenetic signal          in the alignment used                          Inconsistency between orthology bootstrap values          and sequence similarity          We were next interested in the number of sequences in          the two proteomes for which the orthology bootstrap          values do not correspond to sequence similarity Table           Such disagreements could be caused by the situation          illustrated in Figure  To determine these numbers we          used the following rules Two thresholds for orthology          bootstrap values were chosen           O  the minimum for being an          ortholog eg  and           N  the maximum for not being an          ortholog eg  Furthermore a maximal ratio           R for the distance of the query to          nonorthologs to the distance of the query to orthologs          was chosen eg  In order for being counted as          exhibiting disagreement between the orthology bootstrap          values and sequence similarity a query sequence had to          fulfill the following two conditions i it must have a          least one ortholog with bootstrap orthology value above          or equal to           O  and ii           all sequences in the alignment with          bootstrap orthology values above           N  must have distance ratios          smaller or equal to           R for at least one sequence with          bootstrap orthology lower or equal to           N  Sequences from the following          species were ignored in this analysis since they were          the species of the query sequence or related to it           A thaliana proteome           Rosidae            A thaliana Pisum sativum            Glycine max            Cucurbita maxima            Cucumis sativus            Brassica campestris            Brassica napus            Citrus unshiu            Citrus sinensis            Theobroma cacao            Gossypium hirsutum            C elegans proteome nematodes            C elegans            Caenorhabditis briggsae            Haemonchus contortus            Ascaris suum           Manual inspection of the RIO output leads to the          following somewhat unexpected conclusion In many cases          a discrepancy between orthology bootstrap values and          sequence similarity is caused by orthologs in only          phylogenetically distant relatively to the query          sequence species This can lead to errors if functional          annotation is blindly transferred from these orthologs to          the query As an example of this the results of          analyzing the           A thaliana Omethyltransferase          FP are shown in Figures and  Complete files          are at here Even though the FP sequence is          orthologous to the bacterial hydroxyneurosporene          methyltransferases EC     it would be          dangerous to annotate it as such A more reasonable          annotation for this query would be to annotate it based          on subtreeneighbors and hence call it a plant          Omethyltransferase An indication of this problem          besides a discrepancy between orthology bootstrap values          and sequence similarity is the meeting of the following          three conditions A query sequence has i likely          orthologs and ii likely subtreeneighbors in other          species than the query itself yet iii there is no          significant overlap between the orthologs and the          subtreeneighbors          We were unable to find convincing examples in the           C elegans and           A thaliana proteomes where wrong          sequence similarity based annotations might be caused by          unequal rates of evolution as illustrated in Figure           This is not to say that such cases do not exist in those          two proteomes but they are likely to be quite rare          Similarly to the issues described in the previous          section the detection of such examples is complicated by          the fact that for many cases in which a discrepancy          between orthology bootstrap values and sequence          similarity exists all sequences in the Pfam alignment          appear to have to same function the Pfam family is          lineage specific or the annotations are too          poorconfusing to make any kind of inference                            Conclusions        RIO is a procedure for automated phylogenomics The RIO        procedure appears to be particularly useful for the        detection of first representatives of novel protein        subfamilies Sequence similarity based methods can be        misleading in these cases since every query is always most        similar to something whereas RIO can detect the absence        of orthologs        Storm Sonnhammer and colleagues have recently        developed similar ideas and procedures in a program called        ORTHOSTRAPPER      One distinction between the two        approaches is that ORTHOSTRAPPERs orthology determination        procedure does not employ a species tree for duplication        inference it uses a heuristic based on sequence similarity        rather than a formally correct phylogenetic means of        inferring orthology Another distinction is that        ORTHOSTRAPPER uses uncorrected observed mismatches as a        sequence distance measure rather than estimating        evolutionary distances In general RIO brings more of the        power of known phylogenetic inference algorithms to bear on        the problem of proteomic annotation        Superorthology is a very stringent criterion If a        query sequence is likely to have superorthologs they        represent an excellent source to transfer functional        annotation from In contrast the absence of        superorthologs does not imply that a function for a query        sequence cannot be inferred in the two proteomes analyzed        in this work most sequences appear to have no        superorthologs in Pfam         Ultraparalogs are sequences in the same species as the        query and are likely to be the result of recent        duplications and therefore might not have yet undergone        much functional divergence Operationally splice variants        can also be thought of as ultraparalogs at least as long        as protein sequences are considered        Subtreeneighbors have two uses i If the        subtreeneighbors of the query sequence exhibit partial        agreement in their functional annotations the elements in        which they agree might be used to infer a partial        function for the query This is useful for query sequences        that are appear to have no orthologs in the current        databases ii For query sequences that do have orthologs        absence of overlap between the sequences considered        orthologous and those which appear to be subtreeneighbors        raises a red flag indicating that the orthologs are in        phylogenetically distant species relative to the query        Transferring annotation from such orthologs is risky In        this case subtreeneighbors are a more reliable source to        transfer annotation from        RIO outputs warnings if the distance of the query        sequence to other sequences is unusually short or long        relative to other branch lengths on the tree The        usefulness of this was not investigated in this work        A RIO procedure based on Pfam alignments analyzes each        protein domain individually since Pfam is protein family        database based on individual domains     In some        respects it would be preferable to analyze whole protein        sequences but well curated databases of complete protein        alignments are not available to our knowledge However        domainbydomain analysis is not necessarily        disadvantageous Due to domain shuffling many proteins are        mosaic proteins composed of domains with different        evolutionary histories      For such proteins it        makes much sense to analyze each domain individually        Furthermore mosaic proteins from sufficiently distant        species might be impossible to be aligned over more than        one domain at the time since they are unlikely to exhibit        the same domain organization The same is true for multiple        copies of the same domain in protein Each of them is        analyzed individually such proteins often differ in their        number of domain copies and could therefore not be aligned        from end to end for the whole family        In general the concept of annotation consensus is        very important in this work for example consensus between        subtreeneighbors or between subtreeneighbors and        orthologs We have employed this notion loosely A useful        future extension would be to incorporate automated        annotation consensus detection into RIO This would include        annotation of internal nodes of a gene tree with a        biological function Automated consensus detection is        trivial for a highly formalized notation system such as EC        numbers the consensus of EC  and EC  is EC         a oxidoreductase acting on the CHOH group of donors        with NAD or NADP as acceptor     Obviously it is        much more difficult to analyze natural language annotations        in the same manner Perhaps this could be accomplished by        utilizing the set of structured vocabularies of the Gene        Ontology GO project           httpwwwgeneontologyorg            